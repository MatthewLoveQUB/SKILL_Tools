; Rough versions of haskell's fold functions
; Function should be in the form (accumulator list-value) => accumulator
(defun qub::foldl (fn accumulator lst)
  (mapc (lambda (x) (setq accumulator (fn accumulator x))) lst)
  accumulator)

(defun qub::foldr (fn init lst)
  (qub::foldl fn init (reverse lst)))

; Sums a list
(defun qub::sum (lst)
  (qub::foldl plus 0 lst))

; List comprehension modelled after python's
(define_syntax qub::lcmp
  (syntax_rules (for in if)
    ((lcmp expression for element in list)
     (mapcar (lambda (element) expression) list))
    ((lcmp expression for element in list if predicate)
     (mapcar (lambda (element) expression) (setof element list predicate)))))
     
     
(defun qub::takeN (n lst)
  (mapcar (lambda (x) (nth x lst)) (qub::range ?start 0 ?stop n)))
     


