(defun qub::joinLists (lst)
  (qub::foldl append (list) lst))

(defun qub::flattenList (lst)
  (letseq ((outputList (list)))
    (labels  ((helper (a)
              (mapcar (lambda (x) 
                        (if (atom x) (pushf x outputList) (helper x))) 
                      a)))
      (helper lst)
    (reverse outputList))))

; Start is inclusive
; End is exclusive
; (qub::range ?start 0 ?stop 5)
; (0 1 2 3 4)
(defun qub::range (@key (start 0) (stop -1) (step 1))
  (if (lessp stop start)
      (error "End value is lower than start value")
      (let ((values nil)
            (cur_val start))
        (while (lessp cur_val stop)
          (pushf cur_val values)
          (setq cur_val (plus cur_val step)))
        (reverse values))))
        
(defun qub::pushEnd (val lst)
  (pushf val (cdr (last lst))))
  
(defun qub::lastAtom (lst)
  (car (last lst)))
  
(defun qub::addListElems (a b)
  (mapcar plus a b))