; Join a list of lists
(defun qub::joinLists (lst)
  (qub::foldl append (list) lst))

  ; Recursively flatten all lists
(defun qub::flattenList (lst)
  (letseq ((outputList (list)))
    (labels  ((helper (a)
              (mapcar (lambda (x) 
                        (if (atom x) (pushf x outputList) (helper x))) 
                      a)))
      (helper lst)
    (reverse outputList))))

; Start is inclusive
; End is exclusive
; (qub::range ?start 0 ?stop 5)
; (0 1 2 3 4)
(defun qub::range (@key (start 0) (stop -1) (step 1))
  (if (lessp stop start)
      (error "End value is lower than start value")
      (let ((values nil)
            (cur_val start))
        (while (lessp cur_val stop)
          (pushf cur_val values)
          (setq cur_val (plus cur_val step)))
        (reverse values))))
        
; Push a new item to the end of a list		
(defun qub::pushEnd (val lst)
  (pushf val (cdr (last lst))))
  
; Get the last atom from a list  
(defun qub::lastAtom (lst)
  (car (last lst)))
  
; Sum values in two lists 
; >>> (qub::addListElems (list 1 2 3) (list 1 2 3))
; (2 4 6)
(defun qub::addListElems (a b)
  (mapcar plus a b))