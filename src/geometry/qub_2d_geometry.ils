; Using polar coordinates so east is 0 degrees, north 90 etc
; Ensures an angle can't go beyond 360 degrees
(defgeneric qub::fixAngle (angle))

(defmethod qub::fixAngle ((angle fixnum))
  (modulo angle 360))
  
(defmethod qub::fixAngle ((angle flonum))
  (if (negativep angle)
      (plus 360.0 (modf angle 360.0))
      (modf angle 360.0)))
  
; Represents a point in 2D space
(defclass qub::Point2D ()
  ((x @initarg x
      @writer set_x
      @reader get_x)
   (y @initarg y
      @writer set_y
      @reader get_y)))
      
(defmethod printself ((obj qub::Point2D))
  (sprintf nil "[Point2D x: %n y: %n]" (get_x obj) (get_y obj)))      
      
; Helper function      
(defun qub::makePoint2D (x y)
  (makeInstance 'qub::Point2D ?x x ?y y))     

(qub::eqfn qub::Point2D
  (and (qub::almostEqual (get_x a) (get_x b) ?abs_tol 1n)
       (qub::almostEqual (get_y a) (get_y b) ?abs_tol 1n)))

(defmethod qub::pointToList ((x qub::Point2D))
  (list (get_x x) (get_y x)))
       
(defmethod qub::almostEqual ((a qub::Point2D)
                             (b qub::Point2D)
                             @key (rel_tol 0)
                                  (abs_tol 0))
  (and (qub::almostEqual (get_x a) 
                         (get_x b) 
                         ?rel_tol rel_tol 
                         ?abs_tol abs_tol))
       (qub::almostEqual (get_y a) 
                         (get_y b)
                         ?rel_tol rel_tol 
                         ?abs_tol abs_tol))
       
; Represents a rotation action
(defclass qub::Rotation ()
  ((angle @initarg angle
          @writer set_angle
          @reader get_angle)
   (direction @initarg direction
              @writer set_direction
              @reader get_direction)))

(defmethod printself ((obj qub::Rotation))
  (sprintf nil "[Rotation: %n degrees %n]" (get_angle obj) (get_direction obj)))

(defun qub::makeRotation (angle direction)
  (makeInstance 'qub::Rotation
          ?angle angle
          ?direction direction))

; Applies a rotation to a state              
(defmethod qub::rotate ((target qub::State2D) (rotation qub::Rotation))
  (letseq ((f (caseq (get_direction rotation)
                (clockwise difference)
                (anticlockwise plus)))
           (new_angle (f (get_angle target) (get_angle rotation))))
    (qub::makeState2D new_angle (get_pos target))))
                                      
(defmethod qub::rotate ((target number) (rotation qub::Rotation))
  (letseq ((f (caseq (get_direction rotation)
                (clockwise difference)
                (anticlockwise plus)))
           (new_angle (f target (get_angle rotation))))
    new_angle))

(defun qub::degreesToRadians (value "n")
  (times qub::m.PI (quotient value 180.0)))
  
(defun qub::radiansToDegrees (value "n")
  (times 180.0 (quotient value qub::m.PI)))
                  
; Macro for the use of directions
; Contains relative and absolute results so be careful
; Compass directions are absolute
; Forward, back etc are all relative
(define_syntax qub::parseDirection
  (syntax_rules (degrees rads radians face)
    ((_ number degrees)
     number)
    ((_ number radians)
     (qub::radiansToDegrees number))
    ((_ turn number degrees direction)
     (qub::makeRotation number direction))
    ((_ turn number radians direction)
     (qub::makeRotation (qub::radiansToDegrees number) direction))
    ((_ turn direction)
     (caseq direction
       (forward (qub::makeRotation 0 'clockwise))
       (right (qub::makeRotation 90 'clockwise))
       (left (qub::makeRotation 90 'anticlockwise))
       (back (qub::makeRotation 180 'clockwise))))
    ((_ face direction)
     (caseq direction
       ; These are absolute directions
       (north 90)
       (northeast 45)
       (east 0)
       (southeast 315)
       (south 270)
       (southwest 225)
       (west 180)
       (northwest 135)))))