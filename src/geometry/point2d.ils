(defun qub::topPoint (a b)
  (if (greaterp (yCoord a) (yCoord b))
      a
      b))
      
(defun qub::bottomPoint (a b)
  (if (lessp (yCoord a) (yCoord b))
      a
      b))
      
(defun qub::leftPoint (a b)
  (if (lessp (xCoord a) (xCoord b))
      a
      b))

(defun qub::rightPoint (a b)
  (if (greaterp (xCoord a) (xCoord b))
      a
      b))
      
(defun qub::higherp (a b)
  (greaterp (yCoord a) (yCoord b)))
      
; translation should be a list of (hor_mv vert_mov)
(defun qub::movePoint (point translation)
  (qub::addListElems point translation))
  
(defun qub::midPoint (p1 p2 @key (distAlong 0.5))
  (let ((p1Scalar distAlong)
        (p2Scalar (difference 1.0 distAlong)))
  (range
    (plus (times p1Scalar (xCoord p1)) (times p2Scalar (xCoord p2)))
    (plus (times p1Scalar (yCoord p1)) (times p2Scalar (yCoord p2))))))
    
(defun qub::getAngleToPt (refPt targetPt)
  (letseq ((d (mapcar difference targetPt refPt))
           (dx (xCoord d))
           (dy (yCoord d)))
    (qub::radToDeg (atan2 dy dx))))
    
(defun qub::moveAtAngle (pt dist angle)
  (let ((dx (times dist (sin (qub::degToRad angle))))
        (dy (times dist (cos (qub::degToRad angle)))))
    (qub::movePoint pt dx:dy)))