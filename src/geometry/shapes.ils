; Convert an apothem to a circumradius
; Args:
;   apothem: float
;   num_sides: int or float
(defun qub::apothemToCircumradius (apothem num_sides)
  (quotient apothem (cos (quotient qub::m.PI num_sides))))
  
; Find the internal angle of a regular polygon
; Args:
;   sides: int or float
(defun qub::internalAngle (sides)
  (quotient 360.0 sides))
	
; Generate the points of an octagon with a given apothem
; Args:
;   a: float
;      The apothem of the octagon
(defun qub::genOctagon (a)
  (letseq ((angle 45.0)
           (sides 8.0)
           ; circumradius
           (cr (qub::apothemToCircumradius a sides)))
    (qub::lcmp
      ; 90 degrees is north (polar)
      ; Move by angle/2 clockwise so the shape is normal
      (qub::getPoint (difference 202.5 (times n angle)) cr)
      for n in (qub::range ?start 0 ?stop sides))))

; Generate a list of octagons
; Args:
;   w: float
;      Width of octagon line
;   s: float
;      Spacing between the inner octagon's outer edge and the outer octagon's
;      inner edge
;   a: float
;      Apothem of the innermost octagon
;   n: int or float
;      The number of octagons to be generated
(defun qub::genOctagons (w s a n)
  (let (; na = new apothem
        ; Calculate the apothem for the current octagon
        (na (lambda (w s a n)
              (a + w/2.0 + n*(w+s)))))
    (qub::lcmp 
      (qub::genOctagon (na w s a n)) 
      for n in (qub::range ?start 0 ?stop n))))
      
; Create a coil from a list of octagons
; Args:
;   shapes: list of octagons which are generated from qub::genOctagons
;   nSegs: int
;          Number of segments of the shape
(defun qub::octagonsToCoil (shapes nSegs)
  (letseq ((inList (qub::joinLists shapes))
           ; Create the output list with the first point added
           (outList (list (nth 0 inList)))
           ; A counter for the required segments
           (segCount 0))
    ; Iterate until we have all of the points
    (while (neq segCount nSegs)
      ; Add the new point to the end of the out list
      (qub::pushEnd (nth (plus 1 segCount) inList) outList)
      ; Increment the counters
      (setq segCount (segCount + 1))
      ; If we've reached the end of a shape
      ; Add the connecting bridge to the next shape
      ; Need to substract the index of the current shape
      ; Due to how we treat segments
      ; Coordinates of the final segment are 7 15 23 etc
      (if (zerop (mod (segCount + 1) 8))
          (letseq ((currentPoint (nth segCount inList))
                   (previousPoint (nth (segCount - 1) inList))
                   (nextPoint (nth (segCount + 1) inList))
                   (lastPointNextShape (nth (segCount + 8) inList))
                   (newPoint (qub::findIntersectPoint previousPoint
                                                      currentPoint
                                                      nextPoint
                                                      lastPointNextShape)))
            ; Find the intersection point between two lines
            ; (1) The last two points of the current shape
            ;     This is a horizontal line.
            ; (2) The first and last points of the next shape
            ;     This is a diagonal line.
            (qub::pushEnd newPoint outList))
          ; Otherwise do nothing
          nil))
    outList))