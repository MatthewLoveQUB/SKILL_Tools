; Converts an apothem to a circumradius
(defun qub::apothemToCircumradius (apothem num_sides)
  (quotient 
    apothem 
    (cos (quotient 
           qub::m.PI
           num_sides))))
  
; Find the internal angle of a regular polygon
(defun qub::internalAngle (sides)
  (quotient 
    360.0 
    sides))
	
; Generate the points of an octagon with a given apothem
; a = apothem
(defun qub::genOctagon (a)
  (letseq ((angle 45.0)
           (sides 8.0)
           ; circumradius
           (cr (qub::apothemToCircumradius a sides)))
    (qub::lcmp
      ; 90 degrees is north (polar)
      ; Move by angle/2 clockwise so the shape is normal
      (qub::getPoint (difference 202.5 (times n angle)) cr)
      for n in (qub::range ?start 0 ?stop sides))))

; Generate a list of octagons
; w = width
; s = spacing
; a = apothem
; n = number of octagons
(defun qub::genOctagons (w s a n)
  (let (; na = new apothem
        ; Calculate the apothem for the current octagon
        (na (lambda (w s a n)
              (a + w/2.0 + n*(w+s)))))
    (qub::lcmp 
      (qub::genOctagon (na w s a n)) 
      for n in (qub::range ?start 0 ?stop n))))
      
; Create a coil from a list of octagons
; nSegs must be an integer as it is compared with segCount
(defun qub::octagonsToCoil (shapes nSegs)
  (letseq ((inList (qub::joinLists shapes))
           ; Create the output list with the first point added
           (outList (list (nth 0 inList)))
           ; A counter for the required segments
           (segCount 0))
    ; Iterate until we have all of the points
    (while (neq segCount nSegs)
      ; Add the new point to the end of the out list
      (qub::pushEnd (nth (plus 1 segCount) inList) outList)
      ; Increment the counters
      (setq segCount (segCount + 1))
      ; If we've reached the end of a shape
      ; Add the connecting bridge to the next shape
      ; Need to substract the index of the current shape
      ; Due to how we treat segments
      ; Coordinates of the final segment are 7 15 23 etc
      (if (zerop (mod (segCount + 1) 8))
          (letseq ((currentPoint (nth segCount inList))
                   (previousPoint (nth (segCount - 1) inList))
                   (nextPoint (nth (segCount + 1) inList))
                   (lastPointNextShape (nth (segCount + 8) inList))
                   (newPoint (qub::findIntersectPoint previousPoint
                                                      currentPoint
                                                      nextPoint
                                                      lastPointNextShape)))
            ; Find the intersection point between two lines
            ; (1) The last two points of the current shape
            ;     This is a horizontal line.
            ; (2) The first and last points of the next shape
            ;     This is a diagonal line.
            (qub::pushEnd newPoint outList))
          ; Otherwise do nothing
          nil))
    outList))
      
  
        
