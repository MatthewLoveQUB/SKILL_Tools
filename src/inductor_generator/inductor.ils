;;;; file for generating spiral inductors
;;;; only use floats for coordinates                 
;;;; 0 degrees is east. 90 degrees is north

(defun qub::apothemToCircumradius (apothem num_sides)
  (quotient 
    apothem 
    (cos (quotient 
           qub::m.PI
           num_sides))))
  
; Finds the internal angle of a regular polygon
(defun qub::internalAngle (sides)
  (quotient 
    360.0 
    sides))
  
; Degrees to radians
(defun qub::degToRad (value)
  (times 
    qub::m.PI 
    (quotient 
      value 
      180.0)))
  
; Finds a point at a distance and angle from a reference point
(defun qub::getPoint (angle dist @key (ref 0.0:0.0))
  (let ((x (xCoord ref))
        (y (yCoord ref))
        (dx (times 
              dist 
              (cos (qub::degToRad angle))))
        (dy (times 
              dist 
              (sin (qub::degToRad angle)))))
    (range 
      (plus x dx)
      (plus y dy))))
    

; equation taken from here the Line-Line intersection wiki page
(defun qub:::findIntersectPoint (a1 a2 b1 b2)
  (let ((x1 (xCoord a1))
        (x2 (xCoord a2))
        (x3 (xCoord b1))
        (x4 (xCoord b2))
        (y1 (yCoord a1))
        (y2 (yCoord a2))
        (y3 (yCoord b1))
        (y4 (yCoord b2)))
    (let ((x1y2 (times x1 y2))
          (y1x2 (times y1 x2))
          (x3y4 (times x3 y4))
          (y3x4 (times y3 x4)))
      (let ((denominator (difference
                           (times
                             (difference x1 x2)
                             (difference y3 y4))
                           (times
                             (difference y1 y2)
                             (difference x3 x4)))))
      (let ((px (quotient
                  (difference
                    (times
                      (difference x1y2 y1x2)
                      (difference x3 x4))
                    (times
                      (difference x1 x2)
                      (difference x3y4 y3x4)))
                  denominator))
            (py (quotient
                  (difference
                    (times
                      (difference x1y2 y1x2)
                      (difference y3 y4))
                    (times
                      (difference y1 y2)
                      (difference x3y4 y3x4)))
                  denominator)))
        px:py)))))
                      

          
; 0 = half of the internal angle e.g. 45 for a square
; 1 = next point anticlockwise = 135 for a square
(defun qub::getPolyPoint (polyIdx 
                          pointIdx 
                          nsides 
                          circumradius 
                          spacing 
                          width
                          @key 
                          (ref 0.0:0.0))
  (let ((dist (plus 
                circumradius 
                (times 
                  polyIdx 
                  (plus 
                    (qub::apothemToCircumradius spacing nsides)
                    (qub::apothemToCircumradius width nsides)))))
        (angle (plus 
		             (difference 90.0 (quotient (qub::internalAngle nsides) 2.0))
                 (times 
                   pointIdx 
                   (qub::internalAngle nsides)))))
    (qub::getPoint (qub::fixAngle angle) dist ?ref ref)))
    
(defun qub::getSpiralPoints (@key 
                             (completeTurns 2)
                             (additionalSegments 0)
                             (width 10.0)
                             (spacing 5.0)
                             (apothem 50.0)
                             (nsides 8)
                             (ref 0.0:0.0))
  (when (greaterp additionalSegments nsides)
        (error "More additional segments then sides"))
  ; plus width is a hack needed because there is a big with left alignment
  ; right alignment works but needs the apothem increased to compensate
	(let ((circumradius (qub::apothemToCircumradius (plus 
                                                    (quotient 
                                                      width 
                                                      2.0) 
                                                    apothem) 
                                                  nsides)))
    (let ((points nil)
          (getPoint (lambda (polyIdx pointIdx)
                      (qub::getPolyPoint polyIdx 
                                         pointIdx 
                                         nsides 
                                         circumradius 
                                         spacing 
                                         width 
                                         ?ref ref)))
          (maxTurnIdx (if (zerop additionalSegments)
                          (sub1 completeTurns)
                          completeTurns))
          (maxPointIdx (sub1 nsides)))
      (for turnIdx 0 maxTurnIdx
        ; drawing each segment
        (let ((maxPointIdx (if (and (equal turnIdx maxTurnIdx)
                                    (not (zerop additionalSegments)))
                               (sub1 additionalSegments) 
                               maxPointIdx)))
          (for pointIdx 0 maxPointIdx
            (pushf (getPoint turnIdx pointIdx) points)))
        (unless (equal turnIdx maxTurnIdx)
          ; Adding the bridging point to the next spiral
          (let ((fip qub:::findIntersectPoint)
                (refa1 (getPoint turnIdx (sub1 maxPointIdx)))
                (refa2 (getPoint turnIdx maxPointIdx))
                ; Get the first and last points of the next spiral
                ; So we can find the collinear point that intersects them
                (refb1 (getPoint (add1 turnIdx) 0))
                (refb2 (getPoint (add1 turnIdx) maxPointIdx)))
           (pushf (fip refa1 refa2 refb1 refb2) points))))
      (qub:::truncateFirstLastPoints (reverse points)))))
     
(defun qub:::takeN (n lst)
  (mapcar (lambda (x) (nth x lst)) (qub::range ?start 0 ?stop n)))
     
(defun qub:::truncateFirstLastPoints (lst)
  (let ((midPoint (lambda (a b)
                    (range
                      (quotient (plus (xCoord b) (xCoord a)) 2.0)
                      (quotient (plus (yCoord b) (yCoord a)) 2.0)))))
    (rplaca lst (midPoint (car lst) (cadr lst)))
    (let ((rLst (reverse lst)))
      (rplaca rLst (midPoint (car rLst) (cadr rLst)))
      (reverse rLst))))
                      
(defun qub:::drawInductor (@key 
                           (completeTurns 2)
                           (additionalSegments 0)
                           (width 10.0)
                           (spacing 5.0)
                           (apothem 50.0)
                           (nsides 8)
                           (metalLayer "M1")
                           (ref 0.0:0.0))
  (let ((points (qub::getSpiralPoints ?completeTurns completeTurns
                                      ?additionalSegments additionalSegments
                                      ?width width
                                      ?spacing spacing
                                      ?apothem apothem
                                      ?nsides nsides
                                      ?ref ref))
        (offset 0))
    (leCreatePath (geGetEditCellView) 
                  (list metalLayer) 
                  points
                  width
                  "truncateExtend" 
                  offset
                  "center")))

(qub:::drawInductor ?completeTurns 2
                    ?additionalSegments 6
                    ?width 10.0
                    ?spacing 5.0
                    ?apothem 50.0
                    ?nsides 8
                    ?metalLayer "M2")
                    