;;;; file for generating spiral inductors
;;;; only use floats for coordinates                 
;;;; 0 degrees is east. 90 degrees is north

(defun qub::apothemToCircumradius (apothem num_sides)
  (quotient 
    apothem 
    (cos (quotient 
           qub::m.PI
           num_sides))))
  
; Finds the internal angle of a regular polygon
(defun qub::internalAngle (sides)
  (quotient 
    360.0 
    sides))
  
; Degrees to radians
(defun qub::degToRad (value)
  (times 
    qub::m.PI 
    (quotient 
      value 
      180.0)))
  
; Finds a point at a distance and angle from a reference point
(defun qub::getPoint (angle dist @key (ref 0.0:0.0))
  (let ((x (xCoord ref))
        (y (yCoord ref))
        (dx (times 
              dist 
              (cos (qub::degToRad angle))))
        (dy (times 
              dist 
              (sin (qub::degToRad angle)))))
    (range 
      (plus x dx)
      (plus y dy))))
    


(defun qub::findCollinearPoint (unknown ref1 ref2)
  (letseq ((coords (list unknown ref1 ref2))
           (getxCoords (lambda (lst) (mapcar xCoord lst)))
           (getyCoords (lambda (lst) (mapcar yCoord lst)))
           (yCoords (getyCoords coords))
           (xCoords (getxCoords coords))
           (between (lambda (x a b)
                      (let ((larger (max a b))
                            (smaller (min a b)))
                        (and (leqp x larger)
                             (geqp x smaller)))))
           (getn (lambda (lst n) (nthelem n lst)))
           ; Core is just a variable that needs to be caculated
           ; regardless of whether we're looking for x or y
           ;
           ; -(x2y3 - x3y2)
           (core (difference 
                   (times 
                     (getn xCoords 2) 
                     (getn yCoords 3))
                   (times 
                     (getn xCoords 3) 
                     (getn yCoords 2))))
           ; Using the core, calculate the other part of the point
           (findPoint (lambda (f a b)
                        (quotient
                          (f core (times 
                                    (getn a 1) 
                                    (difference 
                                      (getn b 3) 
                                      (getn b 2))))
                          (difference 
                            (getn a 3) 
                            (getn a 2))))))
    ; Does the point lie within the x or y coordinates of the reference points?
    ;
    ; Needs sign inverted but I don't know why.
    ; Probably a bug hiding here somewhere 
    ; or my derivation was wrong
    (if (apply between xCoords)
        ; X coordinate is within. Find the Y coordinate
        (let ((x (xCoord unknown))
              (y (times -1.0 (findPoint difference xCoords yCoords))))
          x:y)
        ; Y coordinate must be within. Find the X coordinate.
        (let ((x (times -1.0 (findPoint plus yCoords xCoords)))
              (y (yCoord unknown)))
          x:y))))
          
; 0 = half of the internal angle e.g. 45 for a square
; 1 = next point anticlockwise = 135 for a square
(defun qub::getPolyPoint (polyIdx 
                          pointIdx 
                          nsides 
                          circumradius 
                          spacing 
                          width
                          @key 
                          (ref 0.0:0.0))
  (let ((dist (plus 
                circumradius 
                (times 
                  polyIdx 
                  (plus 
                    (qub::apothemToCircumradius spacing nsides)
                    (qub::apothemToCircumradius width nsides)))))
        (angle (plus 
                 (quotient 
                   (qub::internalAngle nsides) 
                   2.0)
                 (times 
                   pointIdx 
                   (qub::internalAngle nsides)))))
    (qub::getPoint angle dist ?ref ref)))
    
(defun qub::getSpiralPoints (turns 
                             width 
                             spacing 
                             apothem 
                             nsides
                             @key 
                             (ref 0.0:0.0))
  (let ((circumradius (qub::apothemToCircumradius apothem nsides)))
    (let ((points nil)
          (getPoint (lambda (polyIdx pointIdx)
                      (qub::getPolyPoint polyIdx 
                                         pointIdx 
                                         nsides 
                                         circumradius 
                                         spacing 
                                         width 
                                         ?ref ref)))
          (maxTurnIdx (sub1 turns))
          (maxPointIdx (sub1 nsides)))
      (for turnIdx 0 maxTurnIdx
        (for pointIdx 0 maxPointIdx
          (pushf (getPoint turnIdx pointIdx) points))
        ; Adding the bridging point to the next spiral
        (let ((fcp qub::findCollinearPoint)
              (lastPoint (getPoint turnIdx maxPointIdx))
              ; Get the first and last points of the next spiral
              ; So we can find the collinear point that intersects them
              (ref1 (getPoint (add1 turnIdx) 0))
              (ref2 (getPoint (add1 turnIdx) maxPointIdx)))
          (pushf (fcp lastPoint ref1 ref2) points)))
      (reverse points))))
     
(defun qub:::takeN (n lst)
  (mapcar (lambda (x) (nth x lst)) (qub::range ?start 0 ?stop n))))
     
(leCreatePath (geGetEditCellView) 
              (list "M1") 
              (qub:::takeN 20 (qub::getSpiralPoints 10 10.0 5.0 50.0 8))
              10.0 
              "truncateExtend" 
              0 
              "left")
      
