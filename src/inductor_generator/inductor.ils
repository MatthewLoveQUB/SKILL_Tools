;;;; file for generating spiral inductors
;;;; only use floats for coordinates                 
;;;; 0 degrees is east. 90 degrees is north

(defun qub::apothemToCircumradius (apothem num_sides)
  (quotient 
    apothem 
    (cos (quotient 
           qub::m.PI
           num_sides))))
  
; Finds the internal angle of a regular polygon
(defun qub::internalAngle (sides)
  (quotient 
    360.0 
    sides))
  
; Degrees to radians
(defun qub::degToRad (value)
  (times 
    qub::m.PI 
    (quotient 
      value 
      180.0)))
  
; Finds a point at a distance and angle from a reference point
(defun qub::getPoint (angle dist @key (ref 0.0:0.0))
  (let ((x (xCoord ref))
        (y (yCoord ref))
        (dx (times 
              dist 
              (cos (qub::degToRad angle))))
        (dy (times 
              dist 
              (sin (qub::degToRad angle)))))
    (range 
      (plus x dx)
      (plus y dy))))
    


(defun qub::findCollinearPoint (unknown ref1 ref2)
  (letseq ((coords (list unknown ref1 ref2))
           (getxCoords (lambda (lst) (mapcar xCoord lst)))
           (getyCoords (lambda (lst) (mapcar yCoord lst)))
           (yCoords (getyCoords coords))
           (xCoords (getxCoords coords))
           (between (lambda (x a b)
                      (let ((larger (max a b))
                            (smaller (min a b)))
                        (and (leqp x larger)
                             (geqp x smaller)))))
           (getn (lambda (lst n) (nthelem n lst)))
           ; Core is just a variable that needs to be caculated
           ; regardless of whether we're looking for x or y
           ;
           ; -(x2y3 - x3y2)
           (core (difference 
                   (times 
                     (getn xCoords 2) 
                     (getn yCoords 3))
                   (times 
                     (getn xCoords 3) 
                     (getn yCoords 2))))
           ; Using the core, calculate the other part of the point
           (findPoint (lambda (f a b)
                        (quotient
                          (f core (times 
                                    (getn a 1) 
                                    (difference 
                                      (getn b 3) 
                                      (getn b 2))))
                          (difference 
                            (getn a 3) 
                            (getn a 2))))))
    ; Does the point lie within the x or y coordinates of the reference points?
    ;
    ; Needs sign inverted but I don't know why.
    ; Probably a bug hiding here somewhere 
    ; or my derivation was wrong
    (if (apply between xCoords)
        ; X coordinate is within. Find the Y coordinate
        (let ((x (xCoord unknown))
              (y (times -1.0 (findPoint difference xCoords yCoords))))
          x:y)
        ; Y coordinate must be within. Find the X coordinate.
        (let ((x (times -1.0 (findPoint plus yCoords xCoords)))
              (y (yCoord unknown)))
          x:y))))
          
; equation taken from here the Line-Line intersection wiki page
(defun qub:::findIntersectPoint (a1 a2 b1 b2)
  (let ((x1 (xCoord a1))
        (x2 (xCoord a2))
        (x3 (xCoord b1))
        (x4 (xCoord b2))
        (y1 (yCoord a1))
        (y2 (yCoord a2))
        (y3 (yCoord b1))
        (y4 (yCoord b2)))
    (let ((x1y2 (times x1 y2))
          (y1x2 (times y1 x2))
          (x3y4 (times x3 y4))
          (y3x4 (times y3 x4)))
      (let ((denominator (difference
                           (times
                             (difference x1 x2)
                             (difference y3 y4))
                           (times
                             (difference y1 y2)
                             (difference x3 x4)))))
      (let ((px (quotient
                  (difference
                    (times
                      (difference x1y2 y1x2)
                      (difference x3 x4))
                    (times
                      (difference x1 x2)
                      (difference x3y4 y3x4)))
                  denominator))
            (py (quotient
                  (difference
                    (times
                      (difference x1y2 y1x2)
                      (difference y3 y4))
                    (times
                      (difference y1 y2)
                      (difference x3y4 y3x4)))
                  denominator)))
        px:py)))))
                      

          
; 0 = half of the internal angle e.g. 45 for a square
; 1 = next point anticlockwise = 135 for a square
(defun qub::getPolyPoint (polyIdx 
                          pointIdx 
                          nsides 
                          circumradius 
                          spacing 
                          width
                          @key 
                          (ref 0.0:0.0))
  (let ((dist (plus 
                circumradius 
                (times 
                  polyIdx 
                  (plus 
                    (qub::apothemToCircumradius spacing nsides)
                    (qub::apothemToCircumradius width nsides)))))
        (angle (plus 
                 (quotient 
                   (qub::internalAngle nsides) 
                   2.0)
                 (times 
                   pointIdx 
                   (qub::internalAngle nsides)))))
    (qub::getPoint angle dist ?ref ref)))
    
(defun qub::getSpiralPoints (turns 
                             width 
                             spacing 
                             apothem 
                             nsides
                             @key 
                             (ref 0.0:0.0))
  ; plus width is a hack needed because there is a big with left alignment
  ; right alignment works but needs the apothem increased to compensate
	(let ((circumradius (qub::apothemToCircumradius (plus width apothem) nsides)))
    (let ((points nil)
          (getPoint (lambda (polyIdx pointIdx)
                      (qub::getPolyPoint polyIdx 
                                         pointIdx 
                                         nsides 
                                         circumradius 
                                         spacing 
                                         width 
                                         ?ref ref)))
          (maxTurnIdx (sub1 turns))
          (maxPointIdx (sub1 nsides)))
      (for turnIdx 0 maxTurnIdx
        (for pointIdx 0 maxPointIdx
          (pushf (getPoint turnIdx pointIdx) points))
        ; Adding the bridging point to the next spiral
        (let ((fip qub:::findIntersectPoint)
              (refa1 (getPoint turnIdx (sub1 maxPointIdx)))
              (refa2 (getPoint turnIdx maxPointIdx))
              ; Get the first and last points of the next spiral
              ; So we can find the collinear point that intersects them
              (refb1 (getPoint (add1 turnIdx) 0))
              (refb2 (getPoint (add1 turnIdx) maxPointIdx)))
         (pushf (fip refa1 refa2 refb1 refb2) points)))
      (reverse points))))
     
(defun qub:::takeN (n lst)
  (mapcar (lambda (x) (nth x lst)) (qub::range ?start 0 ?stop n)))
     
(let ((points (qub:::takeN 30 (qub::getSpiralPoints 80 10.0 5.0 70.0 8))))   
	(leCreatePath (geGetEditCellView) 
	              (list "M1") 
	              points
	              10.0 
	              "truncateExtend" 
	              0 
	              "right"))
      
