;;;; Module for generating a spiral inductor

(defun qub:::addPortsSingleTurn (lst firstPoint lastPoint)
  (letseq ((mp (lambda (x) 
                 (qub::midPoint firstPoint lastPoint ?distAlong x)))
           (p1 (mp (quotient 1.0 3.0)))
           (p2 (mp (quotient 2.0 3.0))))
    (setq lst (cons p1 lst))
    (setq lst (reverse lst))
    (setq lst (cons p2 lst))
    lst))
    
; Creates coordinates for a single turn spiral inductor
(defun qub:::oneTurn (getPoint maxTurnIdx maxPointIdx)
  (let ((firstPoint  (getPoint maxTurnIdx 0))
        (lastPoint (getPoint maxTurnIdx maxPointIdx))
        (pts nil))
     (for pointIdx 0 maxPointIdx
         (pushf (getPoint maxTurnIdx pointIdx) pts))
     (letseq ((spiralHalf (qub:::addPortsSingleTurn pts firstPoint lastPoint))
              (spiralTurn (list spiralHalf))
              (spiralCoords (list spiralTurn))
              (bridgeCoords nil))
      (list spiralCoords bridgeCoords))))

(defun qub::getBridgePoints (getPoint bridgePoint maxPointIdx maxHalfPointIdx)
  (if (eq bridgePoint 'top)
      (list (getPoint 0 0)
            (getPoint 0 maxPointIdx))
      (list (getPoint 0 maxHalfPointIdx)
            (getPoint 0 (add1 maxHalfPointIdx)))))

(defun qub:::invertSide (side)
  (if (eq side 'top)
      'bottom
      'top))
            
(defun qub:::getInterconnectsHelper (curSide refPts i width)
  (letseq ((f (if (eq curSide 'top)
                  qub:::sortTopPoint
                  qub:::sortBottomPoint))
           (innerTurnPts (nth i refPts))
           (innerLeftPts (f (car innerTurnPts)))
           (innerRightPts (f (cadr innerTurnPts)))
           (outerTurnPts (nth (add1 i) refPts))
           (outerLeftPts (f (car outerTurnPts)))
           (outerRightPts (f (cadr outerTurnPts))))
    (if (eq curSide 'top)
        (list (cadr outerLeftPts) 
              (car outerLeftPts) 
              (car innerRightPts) 
              (cadr innerRightPts))
        (list (cadr innerLeftPts) 
              (car innerLeftPts) 
              (car outerRightPts) 
              (cadr outerRightPts)))))

            
(defun qub::getInterconnects (width spiralCoords)
  (letseq ((pts nil)
           (refPts (reverse spiralCoords))
           (maxPtIdx (sub1 (length refPts)))
           (nturns (length refPts))
           (curSide (if (evenp nturns)
                               'top
                               'bottom))
           (is qub:::invertSide)
           (gih qub:::getInterconnectsHelper))
    (for i 0 (sub1 maxPtIdx)
      (cond ((zerop i) (pushf (gih curSide refPts i width) pts))
            ((equal i maxPtIdx) t)
            ((evenp i) (pushf (gih curSide refPts i width) pts))
            ((oddp i) (pushf (gih (is curSide) refPts i width) pts))))
    pts))
    
; Arranges the list so the upper point is the car
; The order of the points is unchanged
(defun qub:::sortTopPoint (pts)
  (let ((firstPoint (car pts))
        (lastPoint (car (last pts))))
    (if (greaterp (yCoord firstPoint) (yCoord lastPoint))
        pts
        (reverse pts))))
  
; Arranges the list so the lower point is the car
; The order of the points is unchanged
(defun qub:::sortBottomPoint (pts)
  (reverse (qub:::sortTopPoint pts)))

      
; Gets coordinates for a multi turn spiral inductor
(defun qub:::multiTurn (getPoint maxTurnIdx nsides turns width)
  (letseq ((bridgePoint (if (evenp turns)
                            'bottom
                            'top))
           (spiralCoords nil)
           (maxPointIdx (sub1 nsides))
           (maxHalfPointIdx (sub1 (quotient nsides 2))))
    (for turnIdx 0 maxTurnIdx
      (let ((leftSide nil)
            (rightSide nil))
        (for pIdx 0 maxHalfPointIdx
          (pushf (getPoint turnIdx pIdx) leftSide)
          (pushf (getPoint turnIdx (difference maxPointIdx pIdx)) rightSide))
        ; Reversing the right side as we generated it in reverse
        (setq rightSide (reverse rightSide))
        (pushf (list leftSide rightSide) spiralCoords)))
    (let ((interconnects (qub::getInterconnects width spiralCoords)))
      (list spiralCoords interconnects))))
  
(defun qub::getSymmetricSpiralPoints (@key 
                                      (turns 2)
                                      (width 10.0)
                                      (spacing 5.0)
                                      (apothem 50.0)
                                      (nsides 8)
                                      (rotation_anticlockwise 0.0)
                                      (ref 0.0:0.0))
  (letseq (; format of spiralCoords:
           ; spiralCoords = (turn0 turn1 turn2 ... turnN)
           ; turnN = (left right)
           ; right = (point0 point1 ... pointN)
           (maxTurnIdx (sub1 turns))
           (maxPointIdx (sub1 nsides))
           (atc qub::apothemToCircumradius)
           (circumradius (atc (plus apothem (quotient width 2.0)) nsides))
           (getPoint (lambda (polyIdx pointIdx)
                       (qub::getPolyPoint polyIdx 
                                          pointIdx 
                                          nsides 
                                          circumradius 
                                          spacing 
                                          width
                                          ?rotation_anticlockwise 
                                            rotation_anticlockwise
                                          ?ref ref))))
        ; Conditional to call the appropriate function
        (cond ((equal turns 1) (qub:::oneTurn getPoint maxTurnIdx maxPointIdx))
              (t (qub:::multiTurn getPoint maxTurnIdx nsides turns width)))))
        
(defun qub::drawSymmetricInductor (@key 
                                   (turns 1)
                                   (width 10.0)
                                   (spacing 5.0)
                                   (apothem 50.0)
                                   (nsides 8)
                                   (topMetalLayer "M1")
                                   (bottomMetalLayer "M2")
                                   (rotation_anticlockwise 0.0)
                                   (ref 0.0:0.0))
  (let ((points (qub::getSymmetricSpiralPoints ?turns turns
                                               ?width width
                                               ?spacing spacing
                                               ?apothem apothem
                                               ?nsides nsides
                                               ?rotation_anticlockwise 
                                                 rotation_anticlockwise
                                               ?ref ref))
        (offset 0))
    (let ((spiralCoords (car points))
          (bridgeCoords (cadr points))
          (cp (lambda (pts metLyr)
                (leCreatePath (geGetEditCellView) 
                              (list metLyr) 
                              pts
                              width
                              "truncateExtend" 
                              offset
                              "center"))))
      (foreach turn spiralCoords
        (foreach half turn
          (unless (null half)
            (cp half topMetalLayer))))
      (unless (zerop (length bridgeCoords))
        (foreach pts bridgeCoords
          (cp pts bottomMetalLayer))))))

;(printf "%A\n" (qub::getSymmetricSpiralPoints ?turns 2))
(qub::drawSymmetricInductor ?turns 4
                            ?rotation_anticlockwise 45.0)
