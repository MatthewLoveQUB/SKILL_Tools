;;;; Module for generating a spiral inductor

(defun qub::addPorts (turn ref width)
  (letseq ((left (qub::sortTopPoint (car turn)))
           (right (qub::sortTopPoint (cadr turn)))
           (leftTop (car left))
           (rightTop (car right))
           (leftBottom (qub::lastAtom left))
           (rightBottom (qub::lastAtom right))
           (getPort (lambda (a b f)
                      (letseq ((pt (qub::midPoint a b ?distAlong 0.5))
                               (x (xCoord pt))
                               (y (yCoord pt)))
                        (list (f x width) y))))                      
           (ltPort (getPort leftTop rightTop difference))
           (rtPort (getPort leftTop rightTop plus))
           (lbPort (getPort leftBottom rightBottom difference))
           (rbPort (getPort leftBottom rightBottom plus)))
      (pushf ltPort left)
      (pushf rtPort right)
      (qub::pushEnd lbPort left)
      (qub::pushEnd rbPort right)
      (list left right)))
      
(defun qub::getBridgePoints (getPoint bridgePoint maxPointIdx maxHalfPointIdx)
  (if (eq bridgePoint 'top)
      (list (getPoint 0 0)
            (getPoint 0 maxPointIdx))
      (list (getPoint 0 maxHalfPointIdx)
            (getPoint 0 (add1 maxHalfPointIdx)))))

(defun qub::invertSide (side)
  (if (eq side 'top) 'bottom 'top))
            
(defun qub:::getInterconnectsHelper (curSide refPts i width)
  (letseq ((f (if (eq curSide 'top) 
                  qub::sortTopPoint
                  qub::sortBottomPoint))
           (innerTurnPts (nth i refPts))
           (innerLeftPts (f (car innerTurnPts)))
           (innerRightPts (f (cadr innerTurnPts)))
           (outerTurnPts (nth (add1 i) refPts))
           (outerLeftPts (f (car outerTurnPts)))
           (outerRightPts (f (cadr outerTurnPts)))
           (addX (lambda (pt f)
                   (list (f (xCoord pt) width) (yCoord pt))))
           (getLst (lambda (a b)
                     (list (addX (car a) difference)
                           (car a) 
                           (car b)
                           (addX (car b) plus))))
           (il2or (getLst innerLeftPts outerRightPts))
           (ol2ir (getLst outerLeftPts innerRightPts)))
    (if (eq curSide 'top)
        (list ol2ir il2or)
        (list il2or ol2ir))))

; gbp = getbridgepoint            
(defun qub::getInterconnects (width spiralCoords gbp)
  (letseq ((pts (list nil nil))
           (refPts (reverse spiralCoords))
           ; Outer loop has nothing to connect to
           (maxPtIdx (difference (length refPts) 2))
           (curSide (if (evenp (length refPts)) 'top 'bottom))
           (gih qub:::getInterconnectsHelper))
    ; Adding m1 connection to innermost loop
    (pushf (gbp) (car pts))
    (for i 0 maxPtIdx
      (letseq ((interconnects (gih curSide refPts i width))
               (topInterconnects (car interconnects))
               (bottomInterconnects (cadr interconnects)))
         (pushf topInterconnects (car pts))
         (pushf bottomInterconnects (cadr pts)))
      (setq curSide (qub::invertSide curSide)))
    pts))
    
; Arranges the list so the upper point is the car
; The order of the points is unchanged
(defun qub::sortTopPoint (pts)
  (let ((firstPoint (car pts))
        (lastPoint (car (last pts))))
    (if (greaterp (yCoord firstPoint) (yCoord lastPoint))
        pts
        (reverse pts))))
  
(defun qub::sortBottomPoint (pts)
  (reverse (qub::sortTopPoint pts)))
      
; Gets coordinates for a multi turn spiral inductor
(defun qub::createSymInd (getPoint maxTurnIdx nsides turns width ref)
  (letseq ((bridgePoint (if (evenp turns)
                            'bottom
                            'top))
           (spiralCoords nil)
           (maxPointIdx (sub1 nsides))
           (maxHalfPointIdx (sub1 (quotient nsides 2)))
           (gbp (lambda () 
                  (qub::getBridgePoints getPoint 
                                        bridgePoint 
                                        maxPointIdx 
                                        maxHalfPointIdx))))
    (for turnIdx 0 maxTurnIdx
      (let ((leftSide nil)
            (rightSide nil))
        (for pIdx 0 maxHalfPointIdx
          (pushf (getPoint turnIdx pIdx) leftSide)
          (pushf (getPoint turnIdx (difference maxPointIdx pIdx)) rightSide))
        ; Reversing the right side as we generated it in reverse
        (pushf (list leftSide (reverse rightSide)) spiralCoords)))
    ; Add the extra metal to reduce the gap between each half of the turns
    (setq spiralCoords (mapcar (lambda (turn) (qub::addPorts turn ref width))
                               spiralCoords))
    ; Create the interconnects
    (let ((interconnects (qub::getInterconnects width spiralCoords gbp)))
      (list spiralCoords interconnects))))
  
(defun qub::getSymmetricSpiralPoints (@key 
                                      (turns 2)
                                      (width 10.0)
                                      (spacing 5.0)
                                      (apothem 50.0)
                                      (nsides 8)
                                      (rotation_anticlockwise 0.0)
                                      (ref 0.0:0.0))
  (letseq (; format of spiralCoords:
           ; spiralCoords = (turn0 turn1 turn2 ... turnN)
           ; turnN = (left right)
           ; right = (point0 point1 ... pointN)
           (maxTurnIdx (sub1 turns))
           (maxPointIdx (sub1 nsides))
           (atc qub::apothemToCircumradius)
           (circumradius (atc (plus apothem (quotient width 2.0)) nsides))
           (getPoint (lambda (polyIdx pointIdx)
                       (qub::getPolyPoint polyIdx 
                                          pointIdx 
                                          nsides 
                                          circumradius 
                                          spacing 
                                          width
                                          ?rotation_anticlockwise 
                                            rotation_anticlockwise
                                          ?ref ref))))
        ; Conditional to call the appropriate function
        (qub::createSymInd getPoint maxTurnIdx nsides turns width ref)))
        
(defun qub::drawSymmetricInductor (@key 
                                   (turns 1)
                                   (width 10.0)
                                   (spacing 5.0)
                                   (apothem 50.0)
                                   (nsides 8)
                                   (topMetalLayer "M1")
                                   (bottomMetalLayer "M2")
                                   (figGroupRot "R0")
                                   (ref 0.0:0.0)
                                   (name "SymmInd"))
  (letseq ((points (qub::getSymmetricSpiralPoints ?turns turns
                                                  ?width width
                                                  ?spacing spacing
                                                  ?apothem apothem
                                                  ?nsides nsides
                                                  ?rotation_anticlockwise 45.0
                                                  ?ref ref))
           (offset 0)
           (spiralCoords (car points))
           (bridgeCoords (cadr points))
           (objects nil)
           (cv (geGetEditCellView))
           (cp (lambda (pts metLyr)
                 (let ((obj (leCreatePath cv
                                          (list metLyr) 
                                          pts
                                          width
                                          "truncateExtend" 
                                          offset
                                          "center")))
                    (pushf obj objects)))))
    ; Generating main turns
    (foreach turn spiralCoords
      (foreach half turn
        (cp half topMetalLayer)))
          
    ; Generating interconnects
    (let ((topMetalBridges (car bridgeCoords))
          (bottomMetalBridges (cadr bridgeCoords))
          (drawPts (lambda (pts metal) (foreach p pts (cp p metal)))))
      (drawPts topMetalBridges topMetalLayer)
      (drawPts bottomMetalBridges bottomMetalLayer))
    
    ; creating a fig group to organise the parts
    (let ((fg (dbCreateFigGroup cv name t ref "R0")))
      (foreach o objects
        (dbAddFigToFigGroup fg o))
      (dbMoveFig fg cv (list ref figGroupRot)))))
