;;;; Module for generating a spiral inductor

; Extends the middle sections so they're closer together
;  _       _    
; /         \
; |         |
;
; versus
;
;  ___   ___  
; /         \
; |         |
(defun qub::addPorts (turn ref width nturns turnIdx)
  (letseq ((left (qub::sortTopPoint turn->left))
           (right (qub::sortTopPoint turn->right))
           (getPort 
             (lambda (left right)
               (let ((mp (qub::midPoint left right ?distAlong 0.5)))
                 (list (qub::rightPoint left (qub::mvPtX mp -width))
                       (qub::leftPoint right (qub::mvPtX mp width))))))
           (topPorts (getPort (car left) (car right)))
           (bottomPorts (getPort (qub::lastAtom left) (qub::lastAtom right)))
           (mutLast (lambda (lst obj) (setcar (last lst) obj))))
    (let ((f (if (or (and (evenp nturns) (evenp turnIdx))
                     (and (oddp nturns) (oddp turnIdx)))
             (lambda (p) (mutLast p (qub::mvPtX (cadr p) (width * -0.2))))
             (lambda (p) (setcar p (qub::mvPtX (car p) (width * 0.2)))))))
      (mapcar f (list topPorts bottomPorts)))
    
    ; Making sure that there are no duplicate coordinates added
    (unless (equal (car topPorts) (car left))
      (pushf (car topPorts) left))
    (unless (equal (cadr topPorts) (car right))
      (pushf (cadr topPorts) right))
    (unless (equal (car bottomPorts) (qub::lastAtom left))
      (qub::pushEnd (car bottomPorts) left))
    (unless (equal (cadr bottomPorts) (qub::lastAtom right))
      (qub::pushEnd (cadr bottomPorts) right))
      
    (list left right)))
      
(defun qub::getBridgePoints (getPoint bridgePoint maxPointIdx maxHalfPointIdx)
  (let ((gp (lambda (x) (getPoint 0 x)))
        (x maxPointIdx)
        (y maxHalfPointIdx))
    (if (eq bridgePoint 'bottom)
        (mapcar gp (list 1 0 x (x - 1)))
        (mapcar gp (list (y - 1) y (y + 1) (y + 2))))))

(defun qub::invertSide (side)
  (if (eq side 'top) 
      'bottom 
      'top))
            
(defun qub:::getInterconnectsHelper (curSide refPts i width)
  (letseq ((f (if (eq curSide 'top) 
                  qub::sortTopPoint
                  qub::sortBottomPoint))
           (innerTurnPts (nth i refPts))
           (innerLeftPts (f (car innerTurnPts)))
           (innerRightPts (f (cadr innerTurnPts)))
           (outerTurnPts (nth (add1 i) refPts))
           (outerLeftPts (f (car outerTurnPts)))
           (outerRightPts (f (cadr outerTurnPts)))
           (getLst (lambda (leftPts rightPts)
                      (letseq ((points nil)
                               (leftAngle1 (qub::getAngleToPt (car leftPts) (cadr leftPts)))
                               (leftAngle2 (qub::getAngleToPt (cadr leftPts) (caddr leftPts)))
                               (rightAngle1 (qub::getAngleToPt (car rightPts) (cadr rightPts)))
                               (rightAngle2 (qub::getAngleToPt (cadr rightPts) (caddr rightPts)))
                               (leftDist (qub::getDist (car leftPts) (cadr leftPts)))
                               (rightDist (qub::getDist (car rightPts) (cadr rightPts)))
                               (leftRemainder (difference leftDist width))
                               (rightRemainder (difference rightDist width)))
                        ;(when (minusp leftRemainder)
                        ;  (pushf (qub::moveAtAngle (cadr leftPts) (abs leftRemainder) leftAngle2) points))
                        (pushf (qub::moveAtAngle (car leftPts) (min width leftDist) leftAngle1) points)
                        (pushf (car leftPts) points)
                        (pushf (car rightPts) points)
                        (pushf (qub::moveAtAngle (car rightPts) (min rightDist width) rightAngle1) points)
                        ;(when (minusp rightRemainder)
                        ;  (pushf (qub::moveAtAngle (cadr rightPts) (abs rightRemainder) rightAngle2) points))
                        points)))
           (il2or (getLst innerLeftPts outerRightPts))
           (ol2ir (getLst outerLeftPts innerRightPts)))
    (if (eq curSide 'top)
        (list ol2ir il2or)
        (list il2or ol2ir))))

; gbp = getbridgepoint            
(defun qub::getInterconnects (width points gbp turns) 
  (letseq ((pts (list nil nil))
           ; Outer loop connects to nothing
           (maxPtIdx ((length points) - 2))
           (side (if (evenp turns) 
                     'top 
                     'bottom)))
    (pushf (gbp) (car pts)) ; Adding m1 connection to innermost loop
    (for i 0 maxPtIdx
      (let ((interconnects (qub:::getInterconnectsHelper side points i width)))
         (pushf (car interconnects) (car pts))
         (pushf (cadr interconnects) (cadr pts)))
      (setq side (qub::invertSide side)))
    pts))
    
; Arranges the list so the upper point is the car
; The order of the points is unchanged
(defun qub::sortTopPoint (points)
  (if (qub::higherp (car points) (qub::lastAtom points))
      points
      (reverse points)))
  
(defun qub::sortBottomPoint (pts)
  (reverse (qub::sortTopPoint pts)))
      
(defun qub::getSymmetricSpiralPoints (@key 
                                      (turns 2)
                                      (width 10.0)
                                      (spacing 5.0)
                                      (apothem 50.0)
                                      (nsides 8)
                                      (rotation_anticlockwise 0.0)
                                      (ref 0.0:0.0))
  (letseq (; format of spiralCoords:
           ; spiralCoords = (turn0 turn1 turn2 ... turnN)
           ; turnN = (left right)
           ; right = (point0 point1 ... pointN)
           (atc qub::apothemToCircumradius)
           (getPoint 
            (lambda (polyIdx pointIdx)
              (qub::getPolyPoint 
                polyIdx 
                pointIdx 
                nsides 
                (atc (plus apothem (width / 2.0)) nsides) 
                spacing 
                width
                ?rotation_anticlockwise rotation_anticlockwise
                ?ref ref)))
           (maxPointIdx (sub1 nsides))
           (maxTurnIdx (sub1 turns))
           (maxHalfPointIdx (sub1 (quotient nsides 2)))
           (gbp 
            (lambda () 
              (qub::getBridgePoints 
                getPoint 
                (if (evenp turns) 
                    'top 
                    'bottom) 
                maxPointIdx 
                maxHalfPointIdx)))
           (spiralCoords nil))
    (for turnIdx 0 maxTurnIdx
      (let ((left nil)
            (right nil))
        (for pIdx 0 maxHalfPointIdx
          (pushf (getPoint turnIdx pIdx) left)
          (pushf (getPoint turnIdx (difference maxPointIdx pIdx)) right))
        (pushf (list nil 'left left 'right (reverse right)) spiralCoords)))
        
    ; fixing the order of the spiral coords
    (setq spiralCoords (reverse spiralCoords))
        
    ; Add the extra metal to reduce the gap between each half of the turns
    (setq spiralCoords (mapcar (lambda (trn i) (qub::addPorts trn ref width turns i))
                               spiralCoords
                               (qub::range ?stop (length spiralCoords))))
                               
    (let ((interconnects (qub::getInterconnects width spiralCoords gbp turns)))
      (list spiralCoords interconnects))))