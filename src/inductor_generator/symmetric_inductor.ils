;;;; Module for generating a spiral inductor

(defun qub::addPorts (turn ref width)
  (letseq ((left (qub::sortTopPoint (car turn)))
           (right (qub::sortTopPoint (cadr turn)))
           (getPort (lambda (left right)
                      (letseq ((mp (qub::midPoint left right ?distAlong 0.5))
                               (newleft (qub::movePoint mp (minus width):0))
                               (newRight (qub::movePoint mp width:0)))
                        (list (qub::rightPoint left newleft)
                              (qub::leftPoint right newRight)))))
           (topPorts (getPort (car left) (car right)))
           (bottomPorts (getPort (qub::lastAtom left) (qub::lastAtom right))))
           
      (unless (equal (car topPorts) (car left))
        (pushf (car topPorts) left))
        
      (unless (equal (cadr topPorts) (car right))
        (pushf (cadr topPorts) right))
      
      (unless (equal (car bottomPorts) (qub::lastAtom left))
        (qub::pushEnd (car bottomPorts) left))
      
      (unless (equal (cadr bottomPorts) (qub::lastAtom right))
        (qub::pushEnd (cadr bottomPorts) right))
        
      (list left right)))
      
(defun qub::getBridgePoints (getPoint bridgePoint maxPointIdx maxHalfPointIdx)
  (if (eq bridgePoint 'bottom)
      (list (getPoint 0 1)
            (getPoint 0 0)
            (getPoint 0 maxPointIdx)
            (getPoint 0 (sub1 maxPointIdx)))
      (list (getPoint 0 (sub1 maxHalfPointIdx))
            (getPoint 0 maxHalfPointIdx)
            (getPoint 0 (add1 maxHalfPointIdx))
            (getPoint 0 (plus 2 maxHalfPointIdx)))))

(defun qub::invertSide (side)
  (if (eq side 'top) 
      'bottom 
      'top))
            
(defun qub:::getInterconnectsHelper (curSide refPts i width)
  (letseq ((f (if (eq curSide 'top) 
                  qub::sortTopPoint
                  qub::sortBottomPoint))
           (innerTurnPts (nth i refPts))
           (innerLeftPts (f (car innerTurnPts)))
           (innerRightPts (f (cadr innerTurnPts)))
           (outerTurnPts (nth (add1 i) refPts))
           (outerLeftPts (f (car outerTurnPts)))
           (outerRightPts (f (cadr outerTurnPts)))
           (getLst (lambda (a b)
                     (list (qub::moveAtAngle (car a) width (qub::getAngleToPt (car a) (cadr a)))
                           (car a) 
                           (car b)
                           (qub::moveAtAngle (car b) width (qub::getAngleToPt (car b) (cadr b))))))
           (il2or (getLst innerLeftPts outerRightPts))
           (ol2ir (getLst outerLeftPts innerRightPts)))
    (if (eq curSide 'top)
        (list ol2ir il2or)
        (list il2or ol2ir))))

; gbp = getbridgepoint            
(defun qub::getInterconnects (width points gbp turns) 
  (letseq ((pts (list nil nil))
           ; Outer loop connects to nothing
           (maxPtIdx (difference (length points) 2))
           (side (if (evenp turns) 
                     'top 
                     'bottom)))
    (pushf (gbp) (car pts)) ; Adding m1 connection to innermost loop
    (for i 0 maxPtIdx
      (let ((interconnects (qub:::getInterconnectsHelper side points i width)))
         (pushf (car interconnects) (car pts))
         (pushf (cadr interconnects) (cadr pts)))
      (setq side (qub::invertSide side)))
    pts))
    
; Arranges the list so the upper point is the car
; The order of the points is unchanged
(defun qub::sortTopPoint (points)
  (if (qub::higherp (car points) (qub::lastAtom points))
      points
      (reverse points)))
  
(defun qub::sortBottomPoint (pts)
  (reverse (qub::sortTopPoint pts)))
      
; Gets coordinates for a multi turn spiral inductor
(defun qub::createSymInd (getPoint maxTurnIdx nsides turns width ref)
  (letseq ((maxPointIdx (sub1 nsides))
           (maxHalfPointIdx (sub1 (quotient nsides 2)))
           (gbp (lambda () 
                  (qub::getBridgePoints getPoint 
                                        (if (evenp turns) 'top 'bottom) 
                                        maxPointIdx 
                                        maxHalfPointIdx)))
           (spiralCoords nil))
    (for turnIdx 0 maxTurnIdx
      (let ((leftSide nil)
            (rightSide nil))
        (for pIdx 0 maxHalfPointIdx
          (pushf (getPoint turnIdx pIdx) leftSide)
          (pushf (getPoint turnIdx (difference maxPointIdx pIdx)) rightSide))
        (pushf (list leftSide (reverse rightSide)) spiralCoords)))
        
    ; fixing the order of the spiral coords
    (setq spiralCoords (reverse spiralCoords))
        
    ; Add the extra metal to reduce the gap between each half of the turns
    (setq spiralCoords (mapcar (lambda (trn) (qub::addPorts trn ref width))
                               spiralCoords))
                               
    (let ((interconnects (qub::getInterconnects width spiralCoords gbp turns)))
      (list spiralCoords interconnects))))
  
(defun qub::getSymmetricSpiralPoints (@key 
                                      (turns 2)
                                      (width 10.0)
                                      (spacing 5.0)
                                      (apothem 50.0)
                                      (nsides 8)
                                      (rotation_anticlockwise 0.0)
                                      (ref 0.0:0.0))
  (letseq (; format of spiralCoords:
           ; spiralCoords = (turn0 turn1 turn2 ... turnN)
           ; turnN = (left right)
           ; right = (point0 point1 ... pointN)
           (maxTurnIdx (sub1 turns))
           (maxPointIdx (sub1 nsides))
           (atc qub::apothemToCircumradius)
           (circumradius (atc (plus apothem (quotient width 2.0)) nsides))
           (getPoint (lambda (polyIdx pointIdx)
                       (qub::getPolyPoint polyIdx 
                                          pointIdx 
                                          nsides 
                                          circumradius 
                                          spacing 
                                          width
                                          ?rotation_anticlockwise 
                                            rotation_anticlockwise
                                          ?ref ref))))
                                          
        ; Conditional to call the appropriate function
        (qub::createSymInd getPoint maxTurnIdx nsides turns width ref)))