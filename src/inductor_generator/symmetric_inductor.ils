;;;; Module for generating a spiral inductor

(defun qub:::addPortsMultiTurn (turn ref width)
  (letseq ((left (car turn))
           (right (cadr turn))
           (leftTopSort (qub:::sortTopPoint left))
           (rightTopSort (qub:::sortTopPoint right))
           (leftTop (car leftTopSort))
           (rightTop (car rightTopSort))
           (leftBottom (car (reverse leftTopSort)))
           (rightBottom (car (reverse rightTopSort)))
           (mp qub::midPoint)
           (getPort (lambda (a b f)
                      (letseq ((pt (mp a b ?distAlong 0.5))
                               (x (xCoord pt))
                               (y (yCoord pt)))
                        (list (f x width) y))))                        
           (ltPort (getPort leftTop rightTop difference))
           (rtPort (getPort leftTop rightTop plus))
           (lbPort (getPort leftBottom rightBottom difference))
           (rbPort (getPort leftBottom rightBottom plus)))
    (let ((newLeft leftTopSort)
          (newRight rightTopSort))
      (pushf ltPort newLeft)
      (pushf rtPort newRight)
      ; Adding ports on the other side
      (setq newLeft (reverse newLeft))
      (setq newRight (reverse newRight))
      (pushf lbPort newLeft)
      (pushf rbPort newRight)
      (list newLeft newRight))))
      
(defun qub::getBridgePoints (getPoint bridgePoint maxPointIdx maxHalfPointIdx)
  (if (eq bridgePoint 'top)
      (list (getPoint 0 0)
            (getPoint 0 maxPointIdx))
      (list (getPoint 0 maxHalfPointIdx)
            (getPoint 0 (add1 maxHalfPointIdx)))))

(defun qub:::invertSide (side)
  (if (eq side 'top) 'bottom 'top))
            
(defun qub:::getInterconnectsHelper (curSide refPts i width)
  (letseq ((f (if (eq curSide 'top) 
                  qub:::sortTopPoint
                  qub:::sortBottomPoint))
           (innerTurnPts (nth i refPts))
           (innerLeftPts (f (car innerTurnPts)))
           (innerRightPts (f (cadr innerTurnPts)))
           (outerTurnPts (nth (add1 i) refPts))
           (outerLeftPts (f (car outerTurnPts)))
           (outerRightPts (f (cadr outerTurnPts)))
           (addX (lambda (pt f dx)
                   (list (f (xCoord pt) dx) (yCoord pt))))
           (il2or (list (addX (car innerLeftPts) difference width)
                        (car innerLeftPts) 
                        (car outerRightPts) 
                        (addX (car outerRightPts) plus width)))
           (ol2ir (list (addX (car outerLeftPts) difference width)
                        (car outerLeftPts) 
                        (car innerRightPts) 
                        (addX (car innerRightPts) plus width))))
    (if (eq curSide 'top)
        (list ol2ir il2or)
        (list il2or ol2ir))))

; gbp = getbridgepoint            
(defun qub::getInterconnects (width spiralCoords gbp)
  (letseq ((pts (list nil nil))
           (refPts (reverse spiralCoords))
           ; Outer loop has nothing to connect to
           (maxPtIdx (difference (length refPts) 2))
           (curSide (if (evenp (length refPts)) 'top 'bottom))
           (gih qub:::getInterconnectsHelper))
    ; Adding m1 connection to innermost loop
    (pushf (gbp) (car pts))
    (for i 0 maxPtIdx
      (letseq ((interconnects (gih curSide refPts i width))
               (topInterconnects (car interconnects))
               (bottomInterconnects (cadr interconnects)))
         (pushf topInterconnects (car pts))
         (pushf bottomInterconnects (cadr pts)))
      (setq curSide (qub:::invertSide curSide)))
    pts))
    
; Arranges the list so the upper point is the car
; The order of the points is unchanged
(defun qub:::sortTopPoint (pts)
  (let ((firstPoint (car pts))
        (lastPoint (car (last pts))))
    (if (greaterp (yCoord firstPoint) (yCoord lastPoint))
        pts
        (reverse pts))))
  
(defun qub:::sortBottomPoint (pts)
  (reverse (qub:::sortTopPoint pts)))
      
; Gets coordinates for a multi turn spiral inductor
(defun qub:::createSymInd (getPoint maxTurnIdx nsides turns width ref)
  (letseq ((bridgePoint (if (evenp turns)
                            'bottom
                            'top))
           (spiralCoords nil)
           (maxPointIdx (sub1 nsides))
           (maxHalfPointIdx (sub1 (quotient nsides 2)))
           (gbp (lambda () 
                  (qub::getBridgePoints getPoint 
                                        bridgePoint 
                                        maxPointIdx 
                                        maxHalfPointIdx))))
    (for turnIdx 0 maxTurnIdx
      (let ((leftSide nil)
            (rightSide nil))
        (for pIdx 0 maxHalfPointIdx
          (pushf (getPoint turnIdx pIdx) leftSide)
          (pushf (getPoint turnIdx (difference maxPointIdx pIdx)) rightSide))
        ; Reversing the right side as we generated it in reverse
        (setq rightSide (reverse rightSide))
        (pushf (list leftSide rightSide) spiralCoords)))
    ; Add the extra metal to reduce the gap between each half of the turns
    (setq spiralCoords (mapcar (lambda (turn)
                                 (qub:::addPortsMultiTurn turn ref width))
                               spiralCoords))
    ; Create the interconnects
    (let ((interconnects (qub::getInterconnects width spiralCoords gbp)))
      (list spiralCoords interconnects))))
  
(defun qub::getSymmetricSpiralPoints (@key 
                                      (turns 2)
                                      (width 10.0)
                                      (spacing 5.0)
                                      (apothem 50.0)
                                      (nsides 8)
                                      (rotation_anticlockwise 0.0)
                                      (ref 0.0:0.0))
  (letseq (; format of spiralCoords:
           ; spiralCoords = (turn0 turn1 turn2 ... turnN)
           ; turnN = (left right)
           ; right = (point0 point1 ... pointN)
           (maxTurnIdx (sub1 turns))
           (maxPointIdx (sub1 nsides))
           (atc qub::apothemToCircumradius)
           (circumradius (atc (plus apothem (quotient width 2.0)) nsides))
           (getPoint (lambda (polyIdx pointIdx)
                       (qub::getPolyPoint polyIdx 
                                          pointIdx 
                                          nsides 
                                          circumradius 
                                          spacing 
                                          width
                                          ?rotation_anticlockwise 
                                            rotation_anticlockwise
                                          ?ref ref))))
        ; Conditional to call the appropriate function
        (qub:::createSymInd getPoint maxTurnIdx nsides turns width ref)))
        
(defun qub::drawSymmetricInductor (@key 
                                   (turns 1)
                                   (width 10.0)
                                   (spacing 5.0)
                                   (apothem 50.0)
                                   (nsides 8)
                                   (topMetalLayer "M1")
                                   (bottomMetalLayer "M2")
                                   (rotation_anticlockwise 0.0)
                                   (ref 0.0:0.0))
  (letseq ((points (qub::getSymmetricSpiralPoints ?turns turns
                                                  ?width width
                                                  ?spacing spacing
                                                  ?apothem apothem
                                                  ?nsides nsides
                                                  ?rotation_anticlockwise 
                                                    rotation_anticlockwise
                                                  ?ref ref))
           (offset 0)
           (spiralCoords (car points))
           (bridgeCoords (cadr points))
           (cp (lambda (pts metLyr)
                 (leCreatePath (geGetEditCellView) 
                               (list metLyr) 
                               pts
                               width
                               "truncateExtend" 
                               offset
                               "center"))))
    ; Generating main turns
    (foreach turn spiralCoords
      (foreach half turn
        (unless (null half)
          (cp half topMetalLayer))))
          
    ; Generating interconnects
    (let ((topMetalBridges (car bridgeCoords))
          (bottomMetalBridges (cadr bridgeCoords)))
      (foreach pts topMetalBridges
        (cp pts topMetalLayer))
      (foreach pts bottomMetalBridges
        (cp pts bottomMetalLayer)))))

;(printf "%A\n" (qub::getSymmetricSpiralPoints ?turns 2))
(qub::drawSymmetricInductor ?turns 3
                            ?rotation_anticlockwise 45.0)
