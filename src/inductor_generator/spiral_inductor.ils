(defun qub::getSpiralPoints (@key 
                             (completeTurns 2)
                             (additionalSegments 0)
                             (width 10.0)
                             (spacing 5.0)
                             (apothem 50.0)
                             (nsides 8)
                             (rotation_anticlockwise 0.0)
                             (ref 0.0:0.0))
  (when (greaterp additionalSegments nsides)
        (error "More additional segments then sides"))
  (let ((a2c qub::apothemToCircumradius)
        (fip qub:::findIntersectPoint)
        (maxTurnIdx (if (zerop additionalSegments)
                          (sub1 completeTurns)
                          completeTurns))
        (maxPointIdx (sub1 nsides)))
    (let ((points nil)
          (getPoint 
            (lambda (polyIdx pointIdx)
              (qub::getPolyPoint 
                polyIdx 
                pointIdx 
                nsides 
                (a2c ((width / 2.0) + apothem) nsides)
                spacing 
                width
                ?rotation_anticlockwise rotation_anticlockwise
                ?ref ref)))
          (getMaxPtIdx 
            (lambda (trnIdx)
              (if (and (equal trnIdx maxTurnIdx) additionalSegments)
                  (sub1 additionalSegments) 
                  maxPointIdx))))
      (for turnIdx 0 maxTurnIdx
        ; drawing each segment
        (for pointIdx 0 (getMaxPtIdx turnIdx)
            (pushf (getPoint turnIdx pointIdx) points))
        (unless (equal turnIdx maxTurnIdx)
          ; Adding the bridging point to the next spiral
          (let ((refa1 (getPoint turnIdx (sub1 maxPointIdx)))
                (refa2 (getPoint turnIdx maxPointIdx))
                ; Get the first and last points of the next spiral
                ; So we can find the collinear point that intersects them
                (refb1 (getPoint (add1 turnIdx) 0))
                (refb2 (getPoint (add1 turnIdx) maxPointIdx)))
           (pushf (fip refa1 refa2 refb1 refb2) points))))
    points)))
      
     
(defun qub:::truncateFirstLastPoints (lst)
  (rplaca lst (qub::midPoint (car lst) (cadr lst)))
  (let ((rLst (reverse lst)))
    (rplaca rLst (qub::midPoint (car rLst) (cadr rLst)))
    (reverse rLst)))