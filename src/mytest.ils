(defun qub:::drawShape (nsides radius width spacing layer)
  (letseq ((XSIDE (qub::apothemToSide radius nsides))
           (XSHAPE (qub::makeRegularPolygon nsides XSIDE))
           (side_length (qub::nextSideLength XSHAPE spacing width))
           (shape (qub::makeRegularPolygon nsides side_length))
           (npoints (plus 1 (get_num_sides shape)))
           (points (qub::getnCoordinates shape npoints))
           (get_pos (lambda (x) (qub::pointToList (get_pos x))))
           (newPoints (mapcar get_pos points)))
    (leCreatePath (geGetEditCellView) 
                  (list "M1") 
                  (reverse newPoints)
                  width
                  "truncateExtend"
                  0
                  "left")))

(defun qub:::nsp (prevPnt spacing width shape)            
  (letseq ((state (qub::makeState2D (difference 270
                                                (quotient 45.0 2.0))
                                    prevPnt))
           (cursl (get_side_length shape))
           (nxtsl (qub::nextSideLength shape spacing width))
           (dsl (difference nxtsl cursl))
           (x (quotient dsl 2.0))
           (y (plus spacing width))
           (z (sqrt (plus (times x x) (times y y)))))
    (get_pos (qub::move2D state z))))
    
(defun qub:::drawTwoTurn ()
  (let ((shapePoints (list)) ; List of list of points
        (currentShapePoints nil)
        (currentShape nil)
        (currentSideLength nil)
        (width 10)
        (spacing 10)
        (nsides 8)
        (initialRadius 50)
        (currentStartPos (qub::makePoint2D 0 0)))                      
    ; Generating four octagons
    (for i 0 7
      ; Set the new side length
      (setq currentSideLength (if (null currentSideLength)
                                  (qub::apothemToSide initialRadius nsides)
                                  (qub::nextSideLength currentShape 
                                                       spacing 
                                                       width)))
      ; create the polygon
      (setq currentShape (qub::makeRegularPolygon nsides currentSideLength))
      ; Generate its new coordinates
      (let ((newPts (qub::getCoordinates currentShape ?startPos currentStartPos)))
        (pushf (reverse (mapcar (lambda (p) (qub::pointToList (get_pos p))) newPts)) shapePoints))
      ; Making the next start point
      (setq currentStartPos (qub:::nsp currentStartPos spacing width currentShape)))
    (setq shapePoints (reverse shapePoints))

    (letseq ((finalPoints (list))
             (mp qub::makePoint2D)
             (l2p (lambda (n_point n_lst lst)
                     (let ((point (nth n_point (nth n_lst lst))))
                       (mp (car point) (cadr point))))))
      (for i 0 2
        (for j 0 7 (pushf (nth j (nth i shapePoints)) finalPoints))
        ; add collinear point
        (let ((ukn (mp (car (nth 7 (nth i shapePoints))) nil))
              (ref1 (l2p 7 (add1 i) shapePoints))
              (ref2 (l2p 0 (add1 i) shapePoints)))
          (letseq ((cp (qub::pointToList (qub::findCollinearPoint ukn ref1 ref2)))
                   (firstNxt (nth 0 (nth (add1 i) shapePoints)))
                   (pts (list (mp (car cp) (cadr cp)) ref1 ref2))
                   (lpts (mapcar qub::pointToList pts)))
            ;(when (null (qub::collinear? pts))
            ;      (error "..."))
            (pushf cp finalPoints))))
      (leCreatePath (geGetEditCellView) (list "M1") finalPoints width "truncateExtend" 0 "right"))))

(qub:::drawTwoTurn)
