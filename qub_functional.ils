;map = mapcar
;filter = setof

(defun qub:::foldl (fn init lst)
	(let ((result init))
		(foreach value lst
			(setq result (fn result value)))
		result))

(defmacro qub:::foldr (fn init lst)
	`(foldl ,fn ,init ,(reverse lst)))

(defmacro qub:::sum (lst)
	`(foldl plus 0 ,lst))
        
(define_syntax qub:::lcmp
	(syntax_rules (for in if)
		((lcmp expression for element in list)
		 (mapcar (lambda (element) expression) list))
		((lcmp expression for element in list if predicate)
		 (mapcar (lambda (element) expression) (setof element list predicate)))))
		 	
