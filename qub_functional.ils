;map = mapcar
;filter = setof

(defun foldl (fn init lst)
	(let ((result init))
		(foreach value lst
			(setq result (fn result value)))
		result))

(defmacro foldr (fn init lst)
	`(foldl ,fn ,init ,(reverse lst)))

(defmacro sum (lst)
	`(foldl plus 0 ,lst))
        
(define_syntax lcmp
	(syntax_rules (for in if)
		((lcmp expression for element in list)
		 (mapcar (lambda (element) expression) list))
		((lcmp expression for element in list if predicate)
		 (mapcar (lambda (element) expression) (setof element list predicate)))))
		 	
